\section{指令相关和流水线冲突}

\foreword{
    日出·印象
}{
    克劳德·莫奈
}{
    逆境是人类获得知识的最高学府，难题是人们取得智慧之门。
}{
    Figures/C4.jpg
}

\subsection{指令相关和流水线冲突分析}

前面的设计不考虑流水线冲突，在执行简单指令序列的时候很理想通畅，
可以在每个周期都完成一条指令，但是在现实中并不是每时每刻都如此的称心如意的，
通常都会存在着指令间的相关，对导致指令的实现出错，在下面简单进行举例：

\begin{verbatim}
    add.w $r2, $r1, $r1
    add.w $r3, $r2, $r2
\end{verbatim}

在这个指令序列中，第一条的结果会写入到\texttt{r2}中进行，第二条指令需要使用\texttt{r2}寄存器的值进行运算。

根据我们设计的五级流水结构来看，数据只有在最后的写回阶段才会把结果返回到寄存器堆中，
但是第一条指令在执行阶段的时候，第二条指令（此时处于译码阶段）就需要读取寄存器的堆的值，
但是数据并还没写回到寄存器堆中，就会出现写后读的错误——读取到的是\texttt{r2}寄存器的旧值，进而造成输出的错误。

指令相关分为三类：\highlight{数据相关，控制相关，结构相关}。

如果两条指令访问同一个寄存器或者内存，且至少有一条是写寄存器或者内存的指令，那么便是存在数据相关。（上面的例子便是一种）

如果两个指令一条是转移指令且另外一个是否执行取决于转移指令的执行结果，这便是控制相关。

如果两个指令都使用同一个硬件资源，便是存在结构相关。

\subsection{数据相关引发的冲突}

第一种是写后读（RAW），后面的指令要用到前面指令所写的数据，这便是真相关。

第二种是写后写（WAW），两个指令写同一个单元。

第三种是读后写（WAR），后面指令写入前面所读的单元，即反相关。

在我们设计的五级流水结构中，只有真相关会导致流水线冲突，并不需考虑后两种。（如果有同学想要实现乱序执行流水的话则需要考虑）

那么如何解决此冲突呢？这里给出的最直观简单的解决方法————\highlight{阻塞}，让需要结果的指令一直阻塞在译码级，
等到上一条将结果写回到寄存器堆种，才让其进入执行阶段。

关键在于判断处于译码级的指令是需要等待还是前进的条件如何生成。

我们知道，RAW的出现是因为译码级的指令与后面流水级指令访问同一个寄存器导致的，那么我们只需要判断：
\highlight{此时译码级指令中具有来自非0号寄存器的源操作数，如果这些操作数中任何一个的寄存器号与当前这个时刻的执行，访存和写回级的目的操作数的非0号寄存器号是否相同}。

那么如何阻塞呢，使用\texttt{ready\_go}信号。只需调整译码级的信号即可，他此时不再恒为1，当存在写后读相关的时候，需要把此信号变为0.

\subsection{控制相关的冲突}

我们带入一个情景帮大家去更好的理解：

假设有一个转移指令，PC为\texttt{0x1000}，在第一个时钟周期，它位于取指阶段，
此时的预取指阶段同时已经在计算\texttt{nextpc}了，但是此时是不可能根据转移指令的情况来判断，
因为此时CPU仍不知道此为何指令，更不清楚这是否跳转。\texttt{nexpc}只能顺序设置为\texttt{0x1004}。

在第二个周期，\texttt{0x1000}的指令来到了译码阶段，\texttt{0x1004}来到了取值阶段，此时如果不跳转，
那么预取指仍是顺序取\texttt{0x1008}，\texttt{0x1004}也是需要仍然留在执行路径上，继续顺序执行即可。

如果发生跳转（假设跳转到\texttt{0x3000}），那么需要直接调整预取指阶段的为跳转地址为\texttt{0x3000}，
但是无法改变存在于\texttt{0x1004}的指令存在流水线的事实，他是不可能被执行的。那么如何对待这条指令，下面给出一种方法：

回忆流水线的设计参考，我们如何表示每个流水级上有没有指令————用\texttt{valid}信号来实现的，所以其实非常的简单，只需要用\texttt{valid}信号判断即可。

\highlight{取消一条指令，就是把伴随这个指令的\texttt{valid}变为0}

\subsection{流水线数据前递设计}

我们在上面实现的是用阻塞的方法来解决真相关的问题，其实我们不难发现，其实数据的结果在译码之后的阶段已经算出，
只是还没到写回级进行写回，那我们是不是可以进行一个判断，然后将数据直接送到译码级，这样不就不需要等待了？

这种方法便是前递（forward），也称为旁路（bypass）

\subsubsection{路径设计}

需要将执行，访存，写回三级的数据前递到译码级，主要优先级：EXE>MEM>WB

\subsubsection{控制信号调整}

并不是使用前递就能保证不需要任何阻塞，这个时候就可以把\texttt{ready\_go}信号变为恒为1了吗，显然不行，
现在只需要考虑一种问题————\texttt{load\_delay}问题：

\begin{verbatim}
    ld.w $r2, $r1,0x0;
    add.w $r4, $r3, $r2;
\end{verbatim}

假设此时\texttt{ld}指令位于执行级，\texttt{add.w}便位于译码级，请问下一拍\texttt{add.w}能进入下一级吗？

显然不能，因为此时\texttt{ld}指令还没正确的生成最后结果，仍还是需要将其阻塞一个周期，此时\texttt{ready\_go}信号还是得置为0。

\subsection{实验要求}

在上一章的基础上实现流水线冲突的处理：

\begin{itemize}
    \item 使用阻塞的方法，加入适当的逻辑处理寄存器写后读数据相关引发的流水线冲突，运行对应的func，要求成功通过仿真和上板验证。
    \item 使用前递的方法，加入适当的逻辑处理寄存器写后读数据相关引发的流水线冲突，运行对应的func，要求成功通过仿真和上板验证。
\end{itemize}

