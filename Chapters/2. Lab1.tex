\section{不考虑冲突的简单五级流水划分}\label{lab1}

\foreword{
    有橡树的风景
}{
    亚历山德拉·卡拉梅
}{
    树干总是一成不变，枝叶却纷披而伸展。
}{
    Figures/C8.jpg
}

\subsection{流水级介绍}

在计组理论课上大家已经了解过了流水级的概念，不在这里进行过多的解释。在理想情况下，无阻塞的流水级每周期处理一条指令，相比较于单周期CPU效率能够有显著的提升。

但是很多时候流水级会被阻塞，这就意味着如果如果后面的流水级被阻塞，前面的流水级也立即需要被阻塞。因为此时的后面流水级不通，系统不能接受新的数据，所有前面的流水级必须将原有的数据留在本流水级，否则会导致数据的丢失。

我们在实验中采用的策略是：

给每个流水级都安排一个``管理人员''，能与前后级的管理人员进行互相的沟通交流。他会向后一级发送``下个时刻我有东西给你''的请求，同时向前一级发送``下一个时刻我可以接受你传递来的东西''，这样子每级串联起来环环相扣。给出一个示例的设计代码：

\begin{lstlisting}
    module stallable_pipeline #(
        parameter WIDTH = 32
    ) (
        input wire clk,
        input wire resetn,
        input wire validin,
        input wire [WIDTH-1:0] datain,
        input wire out_allow,
        output wire validout,
        output wire [WIDTH-1:0] dataout
    );
    reg [WIDTH-1:0] pipe1_data;
    reg [WIDTH-1:0] pipe2_data;
    reg [WIDTH-1:0] pipe3_data;
    reg pipe1_valid;
    reg pipe2_valid;
    reg pipe3_valid;

    wire pipe1_allowin;
    wire pipe1_ready_go;
    wire pipe1_to_pipe2_valid;
    assign pipe1_ready_go = ......;
    assign pipe1_allowin = ~pipe1_valid || pipe1_ready_go & pipe2_allowin;
    assign pipe1_to_pipe2_valid = pipe1_valid & pipe1_ready_go;

    always @(posedge clk) begin
        if (~resetn) begin  // 复位使得该触发器数据无效
        pipe1_valid <= 1'b0;
        end else if (pipe1_allowin) begin
        pipe1_valid <= validin;
        end

        if (pipe1_allowin & validin) begin
        pipe1_data <= datain;
        end
    end

    wire pipe2_allowin;
    wire pipe2_ready_go;
    wire pipe2_to_pipe3_valid;
    assign pipe2_ready_go = ......;
    assign pipe2_allowin = ~pipe2_valid || pipe2_ready_go & pipe3_allowin;
    assign pipe2_to_pipe3_valid = pipe2_valid & pipe2_ready_go;

    always @(posedge clk) begin
        if (~resetn) begin
        pipe2_valid <= 1'b0;
        end else if (pipe2_allowin) begin
        pipe2_valid <= pipe1_to_pipe2_valid;
        end
        if (pipe2_allowin & pipe1_to_pipe2_valid) begin
        pipe2_data <= pipe1_data;
        end
    end

    wire pipe3_allowin;
    wire pipe3_ready_go;
    wire pipe3_to_out_valid;  //赋值给validout
    assign pipe3_ready_go = ......;
    assign pipe3_allowin = ~pipe3_valid || pipe3_ready_go & out_allow;
    assign pipe3_to_out_valid = pipe3_valid & pipe3_ready_go;

    always @(posedge clk) begin
        if (~resetn) begin
        pipe3_valid <= 1'b0;
        end else if (pipe3_allowin) begin
        pipe3_valid <= pipe2_to_pipe3_valid;
        end
        if (pipe3_allowin & pipe2_to_pipe3_valid) begin
        pipe3_data <= pipe2_data;
        end
    end
    assign validout = pipe3_to_out_valid;
    assign dataout  = pipe3_data;
    endmodule
\end{lstlisting}


下面对些许信号进行解释：

\texttt{pipex\_valid}表示为第\texttt{x}级的有效位，使用触发器实现，为1的时候表示当前时钟周期时的数据有效，好处在于，当我们需要将流水线清空的时候，不需要将所有\texttt{data}置为0，只需要将\texttt{valid}设为0.

\texttt{pipex\_allowin}是往前传递的信号，为1是表示当前允许接收前一级传入的数据。

\texttt{pipex\_ready\_go}表示当前拍的状态，为1时表示数据在当前级的任务已经完成，可以往后一级传递数据。

\texttt{pipex\_to\_pipex+1\_valid}向后一级传递的信号，为1表示有数据需要在下个周期传入后一级。

\subsection{单周期处理器拆分}

我们设计的是经典的单发射五级流水线划分，从前往后依次是：取值（IF），译码（ID）,执行（EXE），访存（MEM），写回（WB）。

取指阶段的主要功能是将指令取回；

译码阶段的主要功能是解析指令生成控制信号并读取通用寄存器堆生成源操作数；

执行阶段的主要功能是对源操作数进行算术逻辑类指令的运算或者访存指令的地址计算；

访存阶段的主要功能是取回访存的结果；

写回阶段的主要功能是将结果写入通用寄存
器堆。

结合这个流水线阶段的划分方案，我们将之前设计的单发射 CPU 的数据通路拆分为五段，
并在各段之间加入触发器作为流水线缓存。

这里给出取指级的详细代码：

\begin{lstlisting}
    `include "mycpu_head.v"

    module IF_stage(
        input wire clk,
        input wire reset,
        input wire ds_allowin,
        input wire [`BR_BUS_WD  -1 :0] br_bus,
        output     wire             fs_to_ds_valid,
        output wire [`FS_TO_DS_BUS_WD-1 :0] fs_to_ds_bus,
        // inst sram interface
        output wire inst_sram_en,
        output wire [3:0] inst_sram_we,
        output wire [31:0] inst_sram_addr,
        output wire [31:0] inst_sram_wdata,
        input  wire [31:0] inst_sram_rdata
        );
        //if级握手信号
        reg         fs_valid; 
        wire        fs_ready_go;
        wire        fs_allowin;
        wire        to_fs_valid; 
        
        wire [31:0] seq_pc; //顺序的地址
        wire [31:0] next_pc; //下一个执行的地址，可能会跳转
        
        wire br_taken; //跳转信号
        wire [31:0] br_target;//跳转地址
        
        assign {br_taken,br_target} = br_bus; //跳转信号传递
        
        wire [31:0] fs_inst; //fs阶段的inst和pc,往后传递
        reg [31:0] fs_pc;
        
        //if向id传递的bus
        assign fs_to_ds_bus = {fs_inst,fs_pc};
        
        //pre-if stage
        assign to_fs_valid = ~reset; 
        assign seq_pc = fs_pc + 3'h4; //顺序
        assign next_pc = (br_taken == 1 ) ? br_target :seq_pc; 
        
        //IF stage
        assign fs_ready_go = 1'b1; //可以传输
        assign fs_allowin = !fs_valid || fs_ready_go && ds_allowin; //允许进入，
        assign fs_to_ds_valid = fs_valid && fs_ready_go;
        
        always@(posedge clk)begin
        if(reset)begin
        fs_valid <= 1'b0;
        end else if(fs_allowin)begin
        fs_valid <= to_fs_valid;
        end
        end
        
    always@(posedge clk)begin
        if(reset)begin
        fs_pc <= 32'h1bfffffc;
        end else if(to_fs_valid && fs_allowin)begin
        fs_pc <= next_pc;
    end
    end
    
    assign inst_sram_en = to_fs_valid && fs_allowin;   //
    assign inst_sram_we = 4'h0;  //写
    assign inst_sram_addr =next_pc; 
    assign inst_sram_wdata = 32'b0; 
    
    assign fs_inst = inst_sram_rdata; 
    
    endmodule
\end{lstlisting}

关于转移指令更新 PC ，由于转移指令需要在译码级才能知道正确的跳转方向和目标，所以我们将转移指令的pc修改时间放在译码级，此时我们应该注意，
pre-IF 阶段的 \texttt{nextpc} 生成逻辑中，来自 PC 相对转移指令跳转目标的那一支，其跳转目标计算所用的 PC 是处在译码阶段的转移指令的 PC，不是此时取指阶段的PC。

\texttt{fs\_to\_ds\_bus}存放着每一级的缓存，需要往后传递，它的位宽取决于数据内容的大小，这里通过宏定义
（\texttt{mycpu\_head.v}）进行统一管理,具体如下，xx为自身传递的位宽大小，根据自身设计而定，没有强制要求：

\begin{lstlisting}
    `ifndef MYCPU_H
        `define MYCPU_H

        `define BR_BUS_WD        xx
        `define FS_TO_DS_BUS_WD  xx
        `define DS_TO_ES_BUS_WD  xx
        `define ES_TO_MS_BUS_WD  xx
        `define MS_TO_WS_BUS_WD  xx
        `define WS_TO_RF_BUS_WD  xx
    `endif
\end{lstlisting}

给出译码级的详细代码：

\begin{lstlisting}
    `include "mycpu_head.v"

    module ID_stage(
        input  wire    clk,
        input  wire    reset,
        //allowin
        input  wire    es_allowin,
        output wire    ds_allowin,
        //from if stage
        input   wire        fs_to_ds_valid,
        input wire [`FS_TO_DS_BUS_WD-1 : 0] fs_to_ds_bus,
        //to ex stage
        output  wire         ds_to_es_valid,
        output  wire [`DS_TO_ES_BUS_WD -1 : 0 ] ds_to_es_bus,
        //to if stage
        output wire  [`BR_BUS_WD -1 : 0 ] br_bus   ,
        //to rf :write back
        input  wire  [`WS_TO_RF_BUS_WD -1 :0] ws_to_rf_bus
    );

    wire br_taken;
    wire [31:0] br_target;

    wire [31:0] ds_pc;
    wire [31:0] ds_inst;

    reg         ds_valid;
    wire        ds_ready_go;

    wire [11:0] alu_op;

    wire load_op;  //加载信号
    wire src1_is_pc; //来自src为pc地址
    wire src2_is_imm; //src2为imm
    wire res_from_mem; //result来自mem
    wire dst_is_r1;
    wire gr_we; 
    wire mem_we; 
    wire src_reg_is_rd;
    wire [4:0]dest;
    wire rj_eq_rd;
    wire [31:0]rj_value;
    wire [31:0]rkd_value;
    wire [31:0]imm;
    wire [31:0]br_offs;
    wire [31:0]jirl_offs;

    //分段
    wire [5:0] op_31_26;
    wire [3:0] op_25_22;
    wire [ 1:0] op_21_20;
    wire [ 4:0] op_19_15;

    wire [ 4:0] rd;
    wire [ 4:0] rj;
    wire [ 4:0] rk;

    wire [11:0] i12;
    wire [19:0] i20;
    wire [15:0] i16;
    wire [25:0] i26;

    wire [63:0] op_31_26_d;
    wire [15:0] op_25_22_d;
    wire [ 3:0] op_21_20_d;
    wire [31:0] op_19_15_d;

    wire        inst_add_w;
    wire        inst_sub_w;
    wire        inst_slt;
    wire        inst_sltu;
    wire        inst_nor;
    wire        inst_and;
    wire        inst_or;
    wire        inst_xor;
    wire        inst_slli_w;
    wire        inst_srli_w;
    wire        inst_srai_w;
    wire        inst_addi_w;
    wire        inst_ld_w;
    wire        inst_st_w;
    wire        inst_jirl;
    wire        inst_b;
    wire        inst_bl;
    wire        inst_beq;
    wire        inst_bne;
    wire        inst_lu12i_w;

    wire        need_ui5;
    wire        need_si12;
    wire        need_si16;
    wire        need_si20;
    wire        need_si26;
    wire        src2_is_4;

    wire [ 4:0] rf_raddr1;
    wire [31:0] rf_rdata1;
    wire [ 4:0] rf_raddr2;
    wire [31:0] rf_rdata2;

    wire rf_we ; //写使能
    wire [4:0] rf_waddr;
    wire [31:0] rf_wdata;

    wire [31:0] alu_src1 ;
    wire [31:0] alu_src2;
    wire [31:0] alu_result;

    wire [31:0] mem_result;
    wire [31:0] final_result;

    assign op_31_26  = ds_inst[31:26];
    assign op_25_22  = ds_inst[25:22];
    assign op_21_20  = ds_inst[21:20];
    assign op_19_15  = ds_inst[19:15];

    assign rd   = ds_inst[ 4: 0];
    assign rj   = ds_inst[ 9: 5];
    assign rk   = ds_inst[14:10];
                
    assign i12  = ds_inst[21:10];
    assign i20  = ds_inst[24: 5];
    assign i16  = ds_inst[25:10];
    assign i26  = {ds_inst[ 9: 0], ds_inst[25:10]};

    decoder_6_64 u_dec0(.in(op_31_26 ), .out(op_31_26_d ));
    decoder_4_16 u_dec1(.in(op_25_22 ), .out(op_25_22_d ));
    decoder_2_4  u_dec2(.in(op_21_20 ), .out(op_21_20_d ));
    decoder_5_32 u_dec3(.in(op_19_15 ), .out(op_19_15_d ));

    ///////////////////////////////////
    assign inst_add_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h00];
    assign inst_sub_w  = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h02];
    assign inst_slt    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h04];
    assign inst_sltu   = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h05];
    assign inst_nor    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h08];
    assign inst_and    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h09];
    assign inst_or     = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0a];
    assign inst_xor    = op_31_26_d[6'h00] & op_25_22_d[4'h0] & op_21_20_d[2'h1] & op_19_15_d[5'h0b];
    assign inst_slli_w = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h01];
    assign inst_srli_w = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h09];
    assign inst_srai_w = op_31_26_d[6'h00] & op_25_22_d[4'h1] & op_21_20_d[2'h0] & op_19_15_d[5'h11];
    assign inst_addi_w = op_31_26_d[6'h00] & op_25_22_d[4'ha];
    assign inst_ld_w   = op_31_26_d[6'h0a] & op_25_22_d[4'h2];
    assign inst_st_w   = op_31_26_d[6'h0a] & op_25_22_d[4'h6];
    assign inst_jirl   = op_31_26_d[6'h13];
    assign inst_b      = op_31_26_d[6'h14];
    assign inst_bl     = op_31_26_d[6'h15];
    assign inst_beq    = op_31_26_d[6'h16];
    assign inst_bne    = op_31_26_d[6'h17];
    assign inst_lu12i_w= op_31_26_d[6'h05] & ~ds_inst[25];

    /////////////////////////////////
    assign alu_op[ 0] = inst_add_w | inst_addi_w | inst_ld_w | inst_st_w
                        | inst_jirl | inst_bl;
    assign alu_op[ 1] = inst_sub_w;
    assign alu_op[ 2] = inst_slt;
    assign alu_op[ 3] = inst_sltu;
    assign alu_op[ 4] = inst_and;
    assign alu_op[ 5] = inst_nor;
    assign alu_op[ 6] = inst_or;
    assign alu_op[ 7] = inst_xor;
    assign alu_op[ 8] = inst_slli_w;
    assign alu_op[ 9] = inst_srli_w;
    assign alu_op[10] = inst_srai_w;
    assign alu_op[11] = inst_lu12i_w;
    //信号
    assign need_ui5   =  inst_slli_w | inst_srli_w | inst_srai_w;
    assign need_si12  =  inst_addi_w | inst_ld_w | inst_st_w;
    assign need_si16  =  inst_jirl | inst_beq | inst_bne;
    assign need_si20  =  inst_lu12i_w;
    assign need_si26  =  inst_b | inst_bl;
    assign src2_is_4  =  inst_jirl | inst_bl;

    assign imm = src2_is_4 ? 32'h4                      :
                need_si20 ? {i20[19:0], 12'b0}         :
                need_ui5  ? rk                         :
                {{20{i12[11]}}, i12[11:0]} ;

    assign br_offs = need_si26 ? {{ 4{i26[25]}}, i26[25:0], 2'b0} :
                                {{14{i16[15]}}, i16[15:0], 2'b0} ;

    assign jirl_offs = {{14{i16[15]}}, i16[15:0], 2'b0};

    assign src_reg_is_rd = inst_beq | inst_bne | inst_st_w;

    assign src1_is_pc    = inst_jirl | inst_bl;

    assign src2_is_imm   = inst_slli_w |
                        inst_srli_w |
                        inst_srai_w |
                        inst_addi_w |
                        inst_ld_w   |
                        inst_st_w   |
                        inst_lu12i_w|
                        inst_jirl   |
                        inst_bl     ;

    assign res_from_mem  = inst_ld_w;
    assign dst_is_r1     = inst_bl;
    assign gr_we         = ~inst_st_w & ~inst_beq & ~inst_bne & ~inst_b ;
    assign mem_we        = inst_st_w;
    assign dest          = dst_is_r1 ? 5'd1 : rd;

    assign rf_raddr1 = rj;
    assign rf_raddr2 = src_reg_is_rd ? rd :rk;

    regfile u_regfile(
        .clk    (clk      ),
        .raddr1 (rf_raddr1),
        .rdata1 (rf_rdata1),
        .raddr2 (rf_raddr2),
        .rdata2 (rf_rdata2),
        .we     (rf_we    ),
        .waddr  (rf_waddr ),
        .wdata  (rf_wdata )
        );
        
    assign rj_value  = rf_rdata1;
    assign rkd_value = rf_rdata2;

    assign rj_eq_rd = (rj_value == rkd_value);
    assign br_taken = (   inst_beq  &&  rj_eq_rd
                    || inst_bne  && !rj_eq_rd
                    || inst_jirl
                    || inst_bl
                    || inst_b
                    ) && ds_valid;
    assign br_target = (inst_beq || inst_bne || inst_bl || inst_b) ? (ds_pc + br_offs) :
                                                    /*inst_jirl*/ (rj_value + jirl_offs);
                                                    
    assign br_bus = {br_taken , br_target};

    reg [`FS_TO_DS_BUS_WD-1 : 0] fs_to_ds_bus_r;

    assign {ds_inst,
            ds_pc} = fs_to_ds_bus_r;

    assign {rf_we, //37:37
            rf_waddr, //36:32
            rf_wdata //31:0
            } = ws_to_rf_bus;     
    
    assign ds_to_es_bus = {alu_op       ,  
                        load_op      ,  
                        src1_is_pc   ,   
                        src2_is_imm  ,  
                        src2_is_4    ,  
                        gr_we        , 
                        mem_we       ,   
                        dest         ,   
                        imm          ,  
                        rj_value     ,   
                        rkd_value    ,   
                        ds_pc        ,    
                        res_from_mem
                        };


    //////////////////////////////////////////////////
    assign ds_ready_go    = 1'b1;
    assign ds_allowin     = !ds_valid || ds_ready_go && es_allowin;
    assign ds_to_es_valid = ds_valid && ds_ready_go;
    always @(posedge clk) begin
        if (reset) begin
            ds_valid <= 1'b0;
        end
        else if (ds_allowin) begin
            ds_valid <= fs_to_ds_valid;
        end
        if (fs_to_ds_valid && ds_allowin) begin
            fs_to_ds_bus_r <= fs_to_ds_bus;
        end
    end
                                
    endmodule
\end{lstlisting}

通过分析给出的两级的详细代码，以及此前在上学期我们实现的单周期CPU不难发现，
代码的主要逻辑部分与单周期CPU基本没有差异。现在实现的不考虑冲突的简单五级流水划分的设计就
是将单周期CPU划分为五级，然后在每级中加入数据缓存，同时使用握手信号对流水级进行控制即可。

\subsection{信号控制}

对于 IF 流水阶段来说，由于目前只从指令 RAM 中取回指令，因此当指令位于取指阶段的
时候，指令 RAM 一定可以返回指令码，于是取指阶段的 \texttt{ready\_go} 信号恒为 1。

对于 ID 流水阶段来说，如果我们暂时不考虑上一节所说的转移指令在译码阶段等待延迟槽指令取回的话，
那么由于译码、读寄存器堆都是一拍之内一定可以完成的，所以译码阶段的 \texttt{ready\_go} 信号恒为 1。

对于 EXE 流水阶段来说，由于目前处理的所有指令在这一阶段均只需要一拍就可以完成，
所以 EXE 阶段的 \texttt{ready\_go} 信号恒为 1。

对于 MEM 流水阶段来说，由于目前只从数据 RAM 中取回数据，
因此当 load 类指令位于MEM 阶段的时候，数据 RAM 一定可以返回数据，于是 MEM 阶段的 \texttt{ready\_go} 信号恒为 1。

对于 WB 流水阶段来说，由于写回寄存器堆在一拍之内一定可以完成，因此 WB 阶段的\texttt{ready\_go} 信号恒为 1。

\subsection{流水线缓存}

根据译码级的例子：

\begin{lstlisting}
    assign ds_to_es_bus = {alu_op       ,  
                            load_op      ,  
                            src1_is_pc   ,   
                            src2_is_imm  ,  
                            src2_is_4    ,  
                            gr_we        , 
                            mem_we       ,   
                            dest         ,   
                            imm          ,  
                            rj_value     ,   
                            rkd_value    ,   
                            ds_pc        ,    
                            res_from_mem
                            };

\end{lstlisting}

这是译码阶段向执行阶段发送的流水级缓存，不难看出这里面包括了数据信号以及控制信号，换而言之，包括了往后流水级需要使用的所有信号，举例说明：

\begin{itemize}
    \item 上面的写使能信号（\texttt{gr\_we}）在译码级已经生成，但在写回级才会被使用，这就意味着它被三级流水线缓存隔断，需要一级一级的往后传递，直至写回级被使用。
    \item 上面的\texttt{alu\_op}信号在下个阶段（EXE）就被使用了，那么当执行级向缓存级发送缓存时，便不需要将此信号继续传递下去。
\end{itemize}

根据给出的两个流水级示例，拆分你的单周期CPU，实现一个不考虑冲突的五级流水CPU。


\subsection{实验要求}


将上学期的单周期处理器代码转移到给出的myCPU文件夹中，直接覆盖代码即可，使用\texttt{soc\_bram}/子目录使用tcl命令创建工程，
在此基础上开始进行第一个实验的实现：
\begin{itemize}
    \item 调整CPU顶层接口，增加指令RAM的片选信号 \texttt{inst\_sram\_en} 和数据RAM的片选信号 \texttt{data\_sram\_en。}
    \item 调整CPU顶层接口，将\texttt{inst\_sram\_we} 和 \texttt{data\_sram\_we} 都从1比特的写使能调整为4比特的字节写使能。
    \item 设计一个不考虑相关引发的冲突的单发射五级流水CPU。
    \item 运行对应的func，要求成功通过仿真和上板验证。
\end{itemize}

从现在开始的指令RAM和数据RAM均采用block RAM实现，其访问时需要给出片选信号。为此myCPU 顶层接口中增加指令RAM的片选信号 \texttt{inst\_sram\_en} 和数据RAM的片选信号 \texttt{data\_sram\_en}。两个信号均为1比特，均为高电平有效。

尽管目前存数指令仅实现了st.w，但考虑到后续实践任务的需求，myCPU 顶层接口中的 \texttt{inst\_sram\_we} 和 \texttt{data\_sram\_we} 都从1比特改为4比特，其含义也从RAM的写使能调整为RAM的字节写使能。


